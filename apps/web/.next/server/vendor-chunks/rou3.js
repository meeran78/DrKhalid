"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rou3";
exports.ids = ["vendor-chunks/rou3"];
exports.modules = {

/***/ "(rsc)/../../node_modules/rou3/dist/index.mjs":
/*!**********************************************!*\
  !*** ../../node_modules/rou3/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullProtoObj: () => (/* binding */ NullProtoObj),\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute),\n/* harmony export */   routeToRegExp: () => (/* binding */ routeToRegExp)\n/* harmony export */ });\nconst NullProtoObj = /* @__PURE__ */ (() => {\n\tconst e = function() {};\n\treturn e.prototype = Object.create(null), Object.freeze(e.prototype), e;\n})();\n\n/**\n* Create a new router context.\n*/\nfunction createRouter() {\n\treturn {\n\t\troot: { key: \"\" },\n\t\tstatic: new NullProtoObj()\n\t};\n}\n\nfunction splitPath(path) {\n\tconst [_, ...s] = path.split(\"/\");\n\treturn s[s.length - 1] === \"\" ? s.slice(0, -1) : s;\n}\nfunction getMatchParams(segments, paramsMap) {\n\tconst params = new NullProtoObj();\n\tfor (const [index, name] of paramsMap) {\n\t\tconst segment = index < 0 ? segments.slice(-(index + 1)).join(\"/\") : segments[index];\n\t\tif (typeof name === \"string\") params[name] = segment;\n\t\telse {\n\t\t\tconst match = segment.match(name);\n\t\t\tif (match) for (const key in match.groups) params[key] = match.groups[key];\n\t\t}\n\t}\n\treturn params;\n}\n\n/**\n* Add a route to the router context.\n*/\nfunction addRoute(ctx, method = \"\", path, data) {\n\tmethod = method.toUpperCase();\n\tif (path.charCodeAt(0) !== 47) path = `/${path}`;\n\tpath = path.replace(/\\\\:/g, \"%3A\");\n\tconst segments = splitPath(path);\n\tlet node = ctx.root;\n\tlet _unnamedParamIndex = 0;\n\tconst paramsMap = [];\n\tconst paramsRegexp = [];\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tlet segment = segments[i];\n\t\tif (segment.startsWith(\"**\")) {\n\t\t\tif (!node.wildcard) node.wildcard = { key: \"**\" };\n\t\t\tnode = node.wildcard;\n\t\t\tparamsMap.push([\n\t\t\t\t-(i + 1),\n\t\t\t\tsegment.split(\":\")[1] || \"_\",\n\t\t\t\tsegment.length === 2\n\t\t\t]);\n\t\t\tbreak;\n\t\t}\n\t\tif (segment === \"*\" || segment.includes(\":\")) {\n\t\t\tif (!node.param) node.param = { key: \"*\" };\n\t\t\tnode = node.param;\n\t\t\tif (segment === \"*\") paramsMap.push([\n\t\t\t\ti,\n\t\t\t\t`_${_unnamedParamIndex++}`,\n\t\t\t\ttrue\n\t\t\t]);\n\t\t\telse if (segment.includes(\":\", 1)) {\n\t\t\t\tconst regexp = getParamRegexp(segment);\n\t\t\t\tparamsRegexp[i] = regexp;\n\t\t\t\tnode.hasRegexParam = true;\n\t\t\t\tparamsMap.push([\n\t\t\t\t\ti,\n\t\t\t\t\tregexp,\n\t\t\t\t\tfalse\n\t\t\t\t]);\n\t\t\t} else paramsMap.push([\n\t\t\t\ti,\n\t\t\t\tsegment.slice(1),\n\t\t\t\tfalse\n\t\t\t]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (segment === \"\\\\*\") segment = segments[i] = \"*\";\n\t\telse if (segment === \"\\\\*\\\\*\") segment = segments[i] = \"**\";\n\t\tconst child = node.static?.[segment];\n\t\tif (child) node = child;\n\t\telse {\n\t\t\tconst staticNode = { key: segment };\n\t\t\tif (!node.static) node.static = new NullProtoObj();\n\t\t\tnode.static[segment] = staticNode;\n\t\t\tnode = staticNode;\n\t\t}\n\t}\n\tconst hasParams = paramsMap.length > 0;\n\tif (!node.methods) node.methods = new NullProtoObj();\n\tnode.methods[method] ??= [];\n\tnode.methods[method].push({\n\t\tdata: data || null,\n\t\tparamsRegexp,\n\t\tparamsMap: hasParams ? paramsMap : void 0\n\t});\n\tif (!hasParams) ctx.static[\"/\" + segments.join(\"/\")] = node;\n}\nfunction getParamRegexp(segment) {\n\tconst regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\");\n\treturn /* @__PURE__ */ new RegExp(`^${regex}$`);\n}\n\n/**\n* Find a route by path.\n*/\nfunction findRoute(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst staticNode = ctx.static[path];\n\tif (staticNode && staticNode.methods) {\n\t\tconst staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n\t\tif (staticMatch !== void 0) return staticMatch[0];\n\t}\n\tconst segments = splitPath(path);\n\tconst match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n\tif (match === void 0) return;\n\tif (opts?.params === false) return match;\n\treturn {\n\t\tdata: match.data,\n\t\tparams: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n\t};\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods) {\n\t\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\t\tif (match) return match;\n\t\t}\n\t\tif (node.param && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\tif (node.wildcard && node.wildcard.methods) {\n\t\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (node.static) {\n\t\tconst staticChild = node.static[segment];\n\t\tif (staticChild) {\n\t\t\tconst match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n\t\t\tif (match) return match;\n\t\t}\n\t}\n\tif (node.param) {\n\t\tconst match = _lookupTree(ctx, node.param, method, segments, index + 1);\n\t\tif (match) {\n\t\t\tif (node.param.hasRegexParam) {\n\t\t\t\tconst exactMatch = match.find((m) => m.paramsRegexp[index]?.test(segment)) || match.find((m) => !m.paramsRegexp[index]);\n\t\t\t\treturn exactMatch ? [exactMatch] : void 0;\n\t\t\t}\n\t\t\treturn match;\n\t\t}\n\t}\n\tif (node.wildcard && node.wildcard.methods) return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n}\n\n/**\n* Remove a route from the router context.\n*/\nfunction removeRoute(ctx, method, path) {\n\tconst segments = splitPath(path);\n\treturn _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods && method in node.methods) {\n\t\t\tdelete node.methods[method];\n\t\t\tif (Object.keys(node.methods).length === 0) node.methods = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (segment === \"*\") {\n\t\tif (node.param) {\n\t\t\t_remove(node.param, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.param)) node.param = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (segment.startsWith(\"**\")) {\n\t\tif (node.wildcard) {\n\t\t\t_remove(node.wildcard, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.wildcard)) node.wildcard = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst childNode = node.static?.[segment];\n\tif (childNode) {\n\t\t_remove(childNode, method, segments, index + 1);\n\t\tif (_isEmptyNode(childNode)) {\n\t\t\tdelete node.static[segment];\n\t\t\tif (Object.keys(node.static).length === 0) node.static = void 0;\n\t\t}\n\t}\n}\nfunction _isEmptyNode(node) {\n\treturn node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\n/**\n* Find all route patterns that match the given path.\n*/\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst segments = splitPath(path);\n\tconst matches = _findAll(ctx, ctx.root, method, segments, 0);\n\tif (opts?.params === false) return matches;\n\treturn matches.map((m) => {\n\t\treturn {\n\t\t\tdata: m.data,\n\t\t\tparams: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n\t\t};\n\t});\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n\tconst segment = segments[index];\n\tif (node.wildcard && node.wildcard.methods) {\n\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\tif (node.param) {\n\t\t_findAll(ctx, node.param, method, segments, index + 1, matches);\n\t\tif (index === segments.length && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) matches.push(...match);\n\t\t\t}\n\t\t}\n\t}\n\tconst staticChild = node.static?.[segment];\n\tif (staticChild) _findAll(ctx, staticChild, method, segments, index + 1, matches);\n\tif (index === segments.length && node.methods) {\n\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\treturn matches;\n}\n\nfunction routeToRegExp(route = \"/\") {\n\tconst reSegments = [];\n\tlet idCtr = 0;\n\tfor (const segment of route.split(\"/\")) {\n\t\tif (!segment) continue;\n\t\tif (segment === \"*\") reSegments.push(`(?<_${idCtr++}>[^/]*)`);\n\t\telse if (segment.startsWith(\"**\")) reSegments.push(segment === \"**\" ? \"?(?<_>.*)\" : `?(?<${segment.slice(3)}>.+)`);\n\t\telse if (segment.includes(\":\")) reSegments.push(segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\"));\n\t\telse reSegments.push(segment);\n\t}\n\treturn /* @__PURE__ */ new RegExp(`^/${reSegments.join(\"/\")}/?$`);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3JvdTMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsR0FBRztBQUM5RCx1Q0FBdUMsTUFBTTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3RELDZGQUE2RixpQkFBaUI7QUFDOUcsOEZBQThGLEdBQUc7QUFDakc7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZHJraGFsaWQvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9yb3UzL2Rpc3QvaW5kZXgubWpzP2I2NzkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTnVsbFByb3RvT2JqID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG5cdGNvbnN0IGUgPSBmdW5jdGlvbigpIHt9O1xuXHRyZXR1cm4gZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBPYmplY3QuZnJlZXplKGUucHJvdG90eXBlKSwgZTtcbn0pKCk7XG5cbi8qKlxuKiBDcmVhdGUgYSBuZXcgcm91dGVyIGNvbnRleHQuXG4qL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKCkge1xuXHRyZXR1cm4ge1xuXHRcdHJvb3Q6IHsga2V5OiBcIlwiIH0sXG5cdFx0c3RhdGljOiBuZXcgTnVsbFByb3RvT2JqKClcblx0fTtcbn1cblxuZnVuY3Rpb24gc3BsaXRQYXRoKHBhdGgpIHtcblx0Y29uc3QgW18sIC4uLnNdID0gcGF0aC5zcGxpdChcIi9cIik7XG5cdHJldHVybiBzW3MubGVuZ3RoIC0gMV0gPT09IFwiXCIgPyBzLnNsaWNlKDAsIC0xKSA6IHM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgcGFyYW1zTWFwKSB7XG5cdGNvbnN0IHBhcmFtcyA9IG5ldyBOdWxsUHJvdG9PYmooKTtcblx0Zm9yIChjb25zdCBbaW5kZXgsIG5hbWVdIG9mIHBhcmFtc01hcCkge1xuXHRcdGNvbnN0IHNlZ21lbnQgPSBpbmRleCA8IDAgPyBzZWdtZW50cy5zbGljZSgtKGluZGV4ICsgMSkpLmpvaW4oXCIvXCIpIDogc2VnbWVudHNbaW5kZXhdO1xuXHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgcGFyYW1zW25hbWVdID0gc2VnbWVudDtcblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gc2VnbWVudC5tYXRjaChuYW1lKTtcblx0XHRcdGlmIChtYXRjaCkgZm9yIChjb25zdCBrZXkgaW4gbWF0Y2guZ3JvdXBzKSBwYXJhbXNba2V5XSA9IG1hdGNoLmdyb3Vwc1trZXldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcGFyYW1zO1xufVxuXG4vKipcbiogQWRkIGEgcm91dGUgdG8gdGhlIHJvdXRlciBjb250ZXh0LlxuKi9cbmZ1bmN0aW9uIGFkZFJvdXRlKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgZGF0YSkge1xuXHRtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcblx0aWYgKHBhdGguY2hhckNvZGVBdCgwKSAhPT0gNDcpIHBhdGggPSBgLyR7cGF0aH1gO1xuXHRwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcOi9nLCBcIiUzQVwiKTtcblx0Y29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG5cdGxldCBub2RlID0gY3R4LnJvb3Q7XG5cdGxldCBfdW5uYW1lZFBhcmFtSW5kZXggPSAwO1xuXHRjb25zdCBwYXJhbXNNYXAgPSBbXTtcblx0Y29uc3QgcGFyYW1zUmVnZXhwID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoXCIqKlwiKSkge1xuXHRcdFx0aWYgKCFub2RlLndpbGRjYXJkKSBub2RlLndpbGRjYXJkID0geyBrZXk6IFwiKipcIiB9O1xuXHRcdFx0bm9kZSA9IG5vZGUud2lsZGNhcmQ7XG5cdFx0XHRwYXJhbXNNYXAucHVzaChbXG5cdFx0XHRcdC0oaSArIDEpLFxuXHRcdFx0XHRzZWdtZW50LnNwbGl0KFwiOlwiKVsxXSB8fCBcIl9cIixcblx0XHRcdFx0c2VnbWVudC5sZW5ndGggPT09IDJcblx0XHRcdF0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChzZWdtZW50ID09PSBcIipcIiB8fCBzZWdtZW50LmluY2x1ZGVzKFwiOlwiKSkge1xuXHRcdFx0aWYgKCFub2RlLnBhcmFtKSBub2RlLnBhcmFtID0geyBrZXk6IFwiKlwiIH07XG5cdFx0XHRub2RlID0gbm9kZS5wYXJhbTtcblx0XHRcdGlmIChzZWdtZW50ID09PSBcIipcIikgcGFyYW1zTWFwLnB1c2goW1xuXHRcdFx0XHRpLFxuXHRcdFx0XHRgXyR7X3VubmFtZWRQYXJhbUluZGV4Kyt9YCxcblx0XHRcdFx0dHJ1ZVxuXHRcdFx0XSk7XG5cdFx0XHRlbHNlIGlmIChzZWdtZW50LmluY2x1ZGVzKFwiOlwiLCAxKSkge1xuXHRcdFx0XHRjb25zdCByZWdleHAgPSBnZXRQYXJhbVJlZ2V4cChzZWdtZW50KTtcblx0XHRcdFx0cGFyYW1zUmVnZXhwW2ldID0gcmVnZXhwO1xuXHRcdFx0XHRub2RlLmhhc1JlZ2V4UGFyYW0gPSB0cnVlO1xuXHRcdFx0XHRwYXJhbXNNYXAucHVzaChbXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRyZWdleHAsXG5cdFx0XHRcdFx0ZmFsc2Vcblx0XHRcdFx0XSk7XG5cdFx0XHR9IGVsc2UgcGFyYW1zTWFwLnB1c2goW1xuXHRcdFx0XHRpLFxuXHRcdFx0XHRzZWdtZW50LnNsaWNlKDEpLFxuXHRcdFx0XHRmYWxzZVxuXHRcdFx0XSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKHNlZ21lbnQgPT09IFwiXFxcXCpcIikgc2VnbWVudCA9IHNlZ21lbnRzW2ldID0gXCIqXCI7XG5cdFx0ZWxzZSBpZiAoc2VnbWVudCA9PT0gXCJcXFxcKlxcXFwqXCIpIHNlZ21lbnQgPSBzZWdtZW50c1tpXSA9IFwiKipcIjtcblx0XHRjb25zdCBjaGlsZCA9IG5vZGUuc3RhdGljPy5bc2VnbWVudF07XG5cdFx0aWYgKGNoaWxkKSBub2RlID0gY2hpbGQ7XG5cdFx0ZWxzZSB7XG5cdFx0XHRjb25zdCBzdGF0aWNOb2RlID0geyBrZXk6IHNlZ21lbnQgfTtcblx0XHRcdGlmICghbm9kZS5zdGF0aWMpIG5vZGUuc3RhdGljID0gbmV3IE51bGxQcm90b09iaigpO1xuXHRcdFx0bm9kZS5zdGF0aWNbc2VnbWVudF0gPSBzdGF0aWNOb2RlO1xuXHRcdFx0bm9kZSA9IHN0YXRpY05vZGU7XG5cdFx0fVxuXHR9XG5cdGNvbnN0IGhhc1BhcmFtcyA9IHBhcmFtc01hcC5sZW5ndGggPiAwO1xuXHRpZiAoIW5vZGUubWV0aG9kcykgbm9kZS5tZXRob2RzID0gbmV3IE51bGxQcm90b09iaigpO1xuXHRub2RlLm1ldGhvZHNbbWV0aG9kXSA/Pz0gW107XG5cdG5vZGUubWV0aG9kc1ttZXRob2RdLnB1c2goe1xuXHRcdGRhdGE6IGRhdGEgfHwgbnVsbCxcblx0XHRwYXJhbXNSZWdleHAsXG5cdFx0cGFyYW1zTWFwOiBoYXNQYXJhbXMgPyBwYXJhbXNNYXAgOiB2b2lkIDBcblx0fSk7XG5cdGlmICghaGFzUGFyYW1zKSBjdHguc3RhdGljW1wiL1wiICsgc2VnbWVudHMuam9pbihcIi9cIildID0gbm9kZTtcbn1cbmZ1bmN0aW9uIGdldFBhcmFtUmVnZXhwKHNlZ21lbnQpIHtcblx0Y29uc3QgcmVnZXggPSBzZWdtZW50LnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGlkKSA9PiBgKD88JHtpZH0+W14vXSspYCkucmVwbGFjZSgvXFwuL2csIFwiXFxcXC5cIik7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuXG4vKipcbiogRmluZCBhIHJvdXRlIGJ5IHBhdGguXG4qL1xuZnVuY3Rpb24gZmluZFJvdXRlKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgb3B0cykge1xuXHRpZiAocGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3KSBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG5cdGNvbnN0IHN0YXRpY05vZGUgPSBjdHguc3RhdGljW3BhdGhdO1xuXHRpZiAoc3RhdGljTm9kZSAmJiBzdGF0aWNOb2RlLm1ldGhvZHMpIHtcblx0XHRjb25zdCBzdGF0aWNNYXRjaCA9IHN0YXRpY05vZGUubWV0aG9kc1ttZXRob2RdIHx8IHN0YXRpY05vZGUubWV0aG9kc1tcIlwiXTtcblx0XHRpZiAoc3RhdGljTWF0Y2ggIT09IHZvaWQgMCkgcmV0dXJuIHN0YXRpY01hdGNoWzBdO1xuXHR9XG5cdGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuXHRjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgY3R4LnJvb3QsIG1ldGhvZCwgc2VnbWVudHMsIDApPy5bMF07XG5cdGlmIChtYXRjaCA9PT0gdm9pZCAwKSByZXR1cm47XG5cdGlmIChvcHRzPy5wYXJhbXMgPT09IGZhbHNlKSByZXR1cm4gbWF0Y2g7XG5cdHJldHVybiB7XG5cdFx0ZGF0YTogbWF0Y2guZGF0YSxcblx0XHRwYXJhbXM6IG1hdGNoLnBhcmFtc01hcCA/IGdldE1hdGNoUGFyYW1zKHNlZ21lbnRzLCBtYXRjaC5wYXJhbXNNYXApIDogdm9pZCAwXG5cdH07XG59XG5mdW5jdGlvbiBfbG9va3VwVHJlZShjdHgsIG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4KSB7XG5cdGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XG5cdFx0aWYgKG5vZGUubWV0aG9kcykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBub2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLm1ldGhvZHNbXCJcIl07XG5cdFx0XHRpZiAobWF0Y2gpIHJldHVybiBtYXRjaDtcblx0XHR9XG5cdFx0aWYgKG5vZGUucGFyYW0gJiYgbm9kZS5wYXJhbS5tZXRob2RzKSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IG5vZGUucGFyYW0ubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUucGFyYW0ubWV0aG9kc1tcIlwiXTtcblx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuXHRcdFx0XHRpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHJldHVybiBtYXRjaDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcblx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuXHRcdFx0XHRpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHJldHVybiBtYXRjaDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG5cdGlmIChub2RlLnN0YXRpYykge1xuXHRcdGNvbnN0IHN0YXRpY0NoaWxkID0gbm9kZS5zdGF0aWNbc2VnbWVudF07XG5cdFx0aWYgKHN0YXRpY0NoaWxkKSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgc3RhdGljQ2hpbGQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG5cdFx0XHRpZiAobWF0Y2gpIHJldHVybiBtYXRjaDtcblx0XHR9XG5cdH1cblx0aWYgKG5vZGUucGFyYW0pIHtcblx0XHRjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGlmIChub2RlLnBhcmFtLmhhc1JlZ2V4UGFyYW0pIHtcblx0XHRcdFx0Y29uc3QgZXhhY3RNYXRjaCA9IG1hdGNoLmZpbmQoKG0pID0+IG0ucGFyYW1zUmVnZXhwW2luZGV4XT8udGVzdChzZWdtZW50KSkgfHwgbWF0Y2guZmluZCgobSkgPT4gIW0ucGFyYW1zUmVnZXhwW2luZGV4XSk7XG5cdFx0XHRcdHJldHVybiBleGFjdE1hdGNoID8gW2V4YWN0TWF0Y2hdIDogdm9pZCAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH1cblx0fVxuXHRpZiAobm9kZS53aWxkY2FyZCAmJiBub2RlLndpbGRjYXJkLm1ldGhvZHMpIHJldHVybiBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG59XG5cbi8qKlxuKiBSZW1vdmUgYSByb3V0ZSBmcm9tIHRoZSByb3V0ZXIgY29udGV4dC5cbiovXG5mdW5jdGlvbiByZW1vdmVSb3V0ZShjdHgsIG1ldGhvZCwgcGF0aCkge1xuXHRjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcblx0cmV0dXJuIF9yZW1vdmUoY3R4LnJvb3QsIG1ldGhvZCB8fCBcIlwiLCBzZWdtZW50cywgMCk7XG59XG5mdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4KSB7XG5cdGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XG5cdFx0aWYgKG5vZGUubWV0aG9kcyAmJiBtZXRob2QgaW4gbm9kZS5tZXRob2RzKSB7XG5cdFx0XHRkZWxldGUgbm9kZS5tZXRob2RzW21ldGhvZF07XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMobm9kZS5tZXRob2RzKS5sZW5ndGggPT09IDApIG5vZGUubWV0aG9kcyA9IHZvaWQgMDtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG5cdGlmIChzZWdtZW50ID09PSBcIipcIikge1xuXHRcdGlmIChub2RlLnBhcmFtKSB7XG5cdFx0XHRfcmVtb3ZlKG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG5cdFx0XHRpZiAoX2lzRW1wdHlOb2RlKG5vZGUucGFyYW0pKSBub2RlLnBhcmFtID0gdm9pZCAwO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKHNlZ21lbnQuc3RhcnRzV2l0aChcIioqXCIpKSB7XG5cdFx0aWYgKG5vZGUud2lsZGNhcmQpIHtcblx0XHRcdF9yZW1vdmUobm9kZS53aWxkY2FyZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcblx0XHRcdGlmIChfaXNFbXB0eU5vZGUobm9kZS53aWxkY2FyZCkpIG5vZGUud2lsZGNhcmQgPSB2b2lkIDA7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBjaGlsZE5vZGUgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuXHRpZiAoY2hpbGROb2RlKSB7XG5cdFx0X3JlbW92ZShjaGlsZE5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG5cdFx0aWYgKF9pc0VtcHR5Tm9kZShjaGlsZE5vZGUpKSB7XG5cdFx0XHRkZWxldGUgbm9kZS5zdGF0aWNbc2VnbWVudF07XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMobm9kZS5zdGF0aWMpLmxlbmd0aCA9PT0gMCkgbm9kZS5zdGF0aWMgPSB2b2lkIDA7XG5cdFx0fVxuXHR9XG59XG5mdW5jdGlvbiBfaXNFbXB0eU5vZGUobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5tZXRob2RzID09PSB2b2lkIDAgJiYgbm9kZS5zdGF0aWMgPT09IHZvaWQgMCAmJiBub2RlLnBhcmFtID09PSB2b2lkIDAgJiYgbm9kZS53aWxkY2FyZCA9PT0gdm9pZCAwO1xufVxuXG4vKipcbiogRmluZCBhbGwgcm91dGUgcGF0dGVybnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0aC5cbiovXG5mdW5jdGlvbiBmaW5kQWxsUm91dGVzKGN0eCwgbWV0aG9kID0gXCJcIiwgcGF0aCwgb3B0cykge1xuXHRpZiAocGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3KSBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG5cdGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuXHRjb25zdCBtYXRjaGVzID0gX2ZpbmRBbGwoY3R4LCBjdHgucm9vdCwgbWV0aG9kLCBzZWdtZW50cywgMCk7XG5cdGlmIChvcHRzPy5wYXJhbXMgPT09IGZhbHNlKSByZXR1cm4gbWF0Y2hlcztcblx0cmV0dXJuIG1hdGNoZXMubWFwKChtKSA9PiB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6IG0uZGF0YSxcblx0XHRcdHBhcmFtczogbS5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbS5wYXJhbXNNYXApIDogdm9pZCAwXG5cdFx0fTtcblx0fSk7XG59XG5mdW5jdGlvbiBfZmluZEFsbChjdHgsIG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4LCBtYXRjaGVzID0gW10pIHtcblx0Y29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcblx0aWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG5cdFx0aWYgKG1hdGNoKSBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuXHR9XG5cdGlmIChub2RlLnBhcmFtKSB7XG5cdFx0X2ZpbmRBbGwoY3R4LCBub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEsIG1hdGNoZXMpO1xuXHRcdGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoICYmIG5vZGUucGFyYW0ubWV0aG9kcykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBub2RlLnBhcmFtLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLnBhcmFtLm1ldGhvZHNbXCJcIl07XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y29uc3QgcE1hcCA9IG1hdGNoWzBdLnBhcmFtc01hcDtcblx0XHRcdFx0aWYgKHBNYXA/LltwTWFwPy5sZW5ndGggLSAxXT8uWzJdKSBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjb25zdCBzdGF0aWNDaGlsZCA9IG5vZGUuc3RhdGljPy5bc2VnbWVudF07XG5cdGlmIChzdGF0aWNDaGlsZCkgX2ZpbmRBbGwoY3R4LCBzdGF0aWNDaGlsZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcblx0aWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggJiYgbm9kZS5tZXRob2RzKSB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBub2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLm1ldGhvZHNbXCJcIl07XG5cdFx0aWYgKG1hdGNoKSBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuXHR9XG5cdHJldHVybiBtYXRjaGVzO1xufVxuXG5mdW5jdGlvbiByb3V0ZVRvUmVnRXhwKHJvdXRlID0gXCIvXCIpIHtcblx0Y29uc3QgcmVTZWdtZW50cyA9IFtdO1xuXHRsZXQgaWRDdHIgPSAwO1xuXHRmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygcm91dGUuc3BsaXQoXCIvXCIpKSB7XG5cdFx0aWYgKCFzZWdtZW50KSBjb250aW51ZTtcblx0XHRpZiAoc2VnbWVudCA9PT0gXCIqXCIpIHJlU2VnbWVudHMucHVzaChgKD88XyR7aWRDdHIrK30+W14vXSopYCk7XG5cdFx0ZWxzZSBpZiAoc2VnbWVudC5zdGFydHNXaXRoKFwiKipcIikpIHJlU2VnbWVudHMucHVzaChzZWdtZW50ID09PSBcIioqXCIgPyBcIj8oPzxfPi4qKVwiIDogYD8oPzwke3NlZ21lbnQuc2xpY2UoMyl9Pi4rKWApO1xuXHRcdGVsc2UgaWYgKHNlZ21lbnQuaW5jbHVkZXMoXCI6XCIpKSByZVNlZ21lbnRzLnB1c2goc2VnbWVudC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBpZCkgPT4gYCg/PCR7aWR9PlteL10rKWApLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuXCIpKTtcblx0XHRlbHNlIHJlU2VnbWVudHMucHVzaChzZWdtZW50KTtcblx0fVxuXHRyZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBSZWdFeHAoYF4vJHtyZVNlZ21lbnRzLmpvaW4oXCIvXCIpfS8/JGApO1xufVxuXG5leHBvcnQgeyBOdWxsUHJvdG9PYmosIGFkZFJvdXRlLCBjcmVhdGVSb3V0ZXIsIGZpbmRBbGxSb3V0ZXMsIGZpbmRSb3V0ZSwgcmVtb3ZlUm91dGUsIHJvdXRlVG9SZWdFeHAgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/rou3/dist/index.mjs\n");

/***/ })

};
;